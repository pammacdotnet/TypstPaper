#import "@local/ijimai:0.0.4": *
#let conf = toml("paper.toml")
#let author-photos = conf.authors.map(author => read(author.name + ".jpg", encoding: none))
#show: ijimai.with(
  conf: conf,
  photos: author-photos,
  logo: image("unir logo.svg", width: 17.5%),
  bib-data: read("bibliography.bib", encoding: none),
)
#set text(lang: "en")

#let latex = {
  set text(font: "New Computer Modern")
  box(
    width: 2.55em,
    {
      place(top, dx: 0.1em, dy: .02cm, text(size: 0.7em)[L])
      place(top, dx: 0.3em, text(size: 0.7em)[A])
      place(top, dx: 0.7em)[T]
      place(top, dx: 1.26em, dy: 0.22em)[E]
      place(top, dx: 1.8em)[X]
    },
  )
}


#let code-grid(typ-file) = {
  let typ = read(typ-file)
  grid(
    columns: (2.5fr, 1.5fr),
    rows: (auto, auto),
    gutter: 1pt,
    raw(typ, lang: "typst", block: true), text(size: 7.5pt)[#eval(typ, mode: "markup")],
  )
}

#let code-example(typ-file, caption: none, placement: none) = {
  let typ = read(typ-file)
  figure(
    placement: placement,
    kind: image,
    caption: none,
    grid(
      columns: (2.5fr, 1.5fr),
      rows: (auto, auto),
      gutter: 1pt,
      raw(typ, lang: "typst", block: true), text(size: 7.5pt)[#eval(typ, mode: "markup")],
    ),
  )
}

= Introduction
#first-paragraph(
  conf: conf,
  first-word: "Typst",
)[is a new markup-based typesetting language (and its associated tooling ecosystem) for technical and scientific documents. It is designed to be an alternative both to advanced tools like LaTeX and simpler tools like Word and Google Docs. The goal with Typst is to build a typesetting tool that is highly capable, extensible, reliable, fast and a pleasure to use. For instance, with Typst, it is possible to:]

- Create professional-quality documents with ease.
- Access extensive functionality, including mathematical typesetting, figure management, and an auto-generated table of contents.
- Utilize powerful templates that automatically apply consistent formatting during the writing process.
- Benefit from high-quality typographical output with improved justification and overall layout.
- View changes instantly with real-time preview functionality.
- Clear and understandable error messages for efficient corrections.
- Apply a consistent styling system to configure fonts, margins, headings, lists, and other elements uniformly.
- Work with familiar programming constructs (no complex macros).
- Collaborate seamlessly with team members.
- Modify document formatting at any time.

The Typst ecosystem comprises a refined and simple to use/understand markup language for defining the content, structure and style of a document, a superfast (and community-driven) document renderer, and a companion web application that enables real-time in-browser compilation. All these components will be explored in @sec:markup, @sec:compiler and @sec:typstapp, respectively.
Besides, the project also hosts a repository of extensions, packages and templates, Typst Universe, discussed in @sec:universe. However, given that Typst is becoming popular and its adoption is growing steadily over the years (as observed in @sec:adoption), it is now often compared against the consolidated LaTeX system. For this reason, we will start with quick comparison of both environments.


#show raw.where(block: true): block.with(
  fill: luma(250),
  inset: 4pt,
  radius: 2pt,
)

#show raw: set text(size: 6.5pt, font: "Fira Code")



= Typst and LaTeX <sec:latex>
Typst and LaTeX @Knuth86@Lamport94 are both markup-based typesetting systems, but they differ in several key aspects. Regarding the language and its syntax, Typst employs more intuitive semantics, similar to those found in Markdown @Voegler14, making it cleaner and more accessible. Its commands are designed to work consistently, reducing the need to learn different conventions for each _package_ (concept tackled in @sec:package). Here it is a side-by-side example:
#let affine-typ = read("affine example.typ")
#let affine-tex = read("affine example.tex")

#figure(
  kind: table,
  caption: "Typst vs. LaTeX comparison example.",
  grid(
    columns: (1fr, 1fr),
    rows: (auto, auto),
    gutter: 5pt,
    column-gutter: 3.0pt,
    align(center)[#text(fill: rgb("#229cac"), weight: "extrabold", "Typst")], align(center, latex),
    raw(affine-typ, lang: "typst", block: true), raw(affine-tex, lang: "latex", block: true),
  ),
) <tab:LaTeXvTypst>

#figure(caption: [Ouput generated by the Typst code in @tab:LaTeXvTypst (with the style rules shown in @fig:setshow).])[
  #set text(
    font: "Cantarell",
    ligatures: false,
    size: 9pt,
  )
  #show heading: it => [
    #set align(center)
    #set text(9pt, weight: "bold")
    #block(smallcaps(it.body))
  ]
  #rect(stroke: 0.01cm)[
    #eval(affine-typ, mode: "markup")
  ]
] <fig:affine>

Focusing on the renderer and local installs, Typst offers significantly faster and incremental compilation times, often completing in milliseconds, which allows for shockingly fast instant previews (under the so called _Doherty threshold_ @Doherty82). The compiler (tackled in @sec:compiler) is a single lightweight binary that, when necessary, downloads external packages on-demand, keeping installations minimal and secure. All operations take place in _userland_ (no need for admin priviledges).

Regarding the operating procedure, unlike LaTeX, Typst does not require boilerplate code/project to start a new document: simply creating an empty text file with a `.typ` extension suffices. To make things even simpler, the proyect hosts its own online editing service (discussed in @sec:typstapp). Currently, in the LaTeX world, this can only be achieved through external cloud solutions, such as Overleaf @Ewelina20. A very short summary on the main differences is presented in @tab:diffs.

#figure(
  align(center)[#table(
      columns: (1fr, 2.0fr, 2.0fr),
      align: (auto, left, left),
      table.header(
        [*Feature*],
        align(center)[*#latex*],
        align(center)[#text(fill: rgb("#229cac"), weight: "extrabold", "Typst")],
      ),
      table.hline(stroke: 1pt), stroke: .01cm,
      [Syntax], [Command-based
        (`\command{arg}`)], [Markdown-inspired (`= Heading`, `_italic_`) +
        code mode (`#func()`)],
      [Math Mode], [`$...$` or `\[...\]`, verbose
        (`\frac{}{}`)], [`$...$`, concise (`1/2` auto-fractions, `phi.alt`
        for variants)],
      [Headings], [`\section{}`, `\subsection{}`], [`= Heading`,
        `== Subheading` (no backslashes)],
      [Lists], [`itemize`/`enumerate` environments], [`-`
        (bullets), `+` (numbers), `/ Term:` (descriptions)],
      [Commands], [Macros
        (`\newcommand`)], [First-class functions (`#let f(x) = x + 1`),
        composable],
      [Compilation], [Slow (seconds), multi-pass], [Fast
        (milliseconds), incremental],
      [Packages], [Large TeX Live/MiKTeX
        distributions], [On-demand cached downloads (@sec:universe)],
      [Errors], [Cryptic], [User-friendly, detailed],
      [Graphics], [TikZ, PSTricks, etc.], [SVG-based (e.g.,
        CeTZ#footnote("http://cetz-package.github.io")), no PDF/EPS support],
      [Team work], [Overleaf (third-party)], [Own
        app for real-time collaboration (@sec:typstapp)],
      [Code blocks], [Limited (e.g., `listings`
        package)], [Tight scripting integration (e.g.,
        `#for x in range(3)[...]`)],
      [Citations], [Mainly managed through BibTeX], [Built-in, no
        external software required],
      [Deploy], [Heavy (GBs)], [Single binary (\~20MB)],
    )],
  kind: table,
  caption: [Main differences between LaTeX and Typst],
) <tab:diffs>

= State of the art

Markup languages and typesetting systems offer several key advantages, including the separation of content from presentation, which allows authors to focus on structure and semantics while ensuring consistent formatting. They also enable automation, such as dynamic content generation, cross-referencing, and bibliography management, reducing manual errors and improving efficiency.

== Typesetting systems and markup languages
Modern typesetting relies heavily on computers, with most printed materials now created digitally rather than through traditional methods like typewriters or movable type. Professional desktop publishing tools such as Adobe InDesign and QuarkXPress offer precise control over elements like kerning and ligatures, while more general-purpose tools like Microsoft Word have adopted some of these features @Chagnon02. Still, these general tools lack the full suite of typesetting capabilities, such as high-quality hyphenation or the ability to flow text across multiple custom regions. This gap has led to the use of text-based systems, especially in academia, where LaTeX dominates due to its powerful formula rendering and flexible layout control.

These systems rely on compiling source text into formatted outputs like PDFs, separating content from presentation to allow easy reuse and adaptation of document styles @Clark07. Typesetting systems are designed not only to produce high-quality visual documents but also to support the complex process of creating structured content. A well-designed system must consider numerous layout features such as _line_ and _page breaking_, _kerning_, _ligatures_, contextual _glyph positioning_, and the treatment of languages with varied directionalities. Additionally, avoiding formatting issues like _widows_ and _orphans_ is part of achieving professional-quality results. However, this visual precision is only one side of the coin. These systems must also support complex content like sections, tables, and figures in a structured manner (@tab:typesetting).

#figure(
  caption: "Main challenges and their ad hoc algorithms and approaches related to markup-based typesetting systems",
  align(center)[#table(
      columns: (1fr, 2fr, 2fr),
      align: (auto, auto, auto), stroke: .01cm,
      table.header([#strong[Challenge];], [#strong[Description];], [#strong[Algorithm/Approach];]),
      table.hline(stroke: 1pt),
      "Paragraph breaking", [Breaking text into lines with
        aesthetically pleasing spacing/hyphenation], [Knuth-Plass line
        breaking algorithm @Hassan15.],
      [Justification], [Spacing so lines align evenly at margins without looking awkward], [Variable spacing adjustments using the Knuth-Plass model @Knuth81],
      [Grid Layout], [Pptimal space for
        rows/columns in grids], [Constraint-based layout calculation @Feiner98],
      [Page Breaking], [Page division while respecting layout], [Greedy +
        backtracking algorithms @Plass81],
      [Text Shaping (Glyph Selection)], [Selecting the correct
        glyphs depending on context], [Font shaping and
        context-sensitive glyph substitution @Rougier18],
      [Bidirectional Text], [Mixing LTR and
        RTL scripts], [Unicode
        Bidirectional Algorithm @Toledo01],
      [Incremental Layout], [Reusing layout computations
        after small edits], [Constraint-based
        layout cache/region reuse @Fisher91],
      [Styling and Theming], [Consistent styles across documents], [Style scope, cascades, and programmable layouts],
      [Unicode], [Modern scripts, ligatures, and grapheme clusters], [Shaping and grapheme line breaking @Elkhayati2022],
    )],
  kind: table,
) <tab:typesetting>

Historically, the development of markup-based systems began in the 1960s with tools like Runoff and evolved significantly with systems like Troff @Barron87 and TeX. Troff brought enhanced typographic features to Unix environments, while TeX revolutionized typesetting with its advanced paragraph layout algorithms and extensible macro system. LaTeX, built on top of TeX, pushed the concept further by introducing _descriptive markup_, where authors focus on the logical structure of content rather than its appearance. Parallel to this, systems like GML, SGML, and eventually HTML and XML developed the idea of defining structure through custom tags @Derose97, with SGML forming the basis for later web standards. Over time (@fig:mlevolution), styling systems like CSS and XSL emerged to handle the transformation of structured content into presentational formats @Cole00. Yet, limitations persisted, such as verbosity in XML and complexity in LaTeX customization.


#figure(
  image("typesetting systems.svg", width: 99%),
  kind: image,
  caption: [Evolution of some Typessetting technologies.],
  placement: none,
) <fig:mlevolution>

// #import "@preview/nulite:0.1.0" as vegalite
// #vegalite.render(
//   width: 100%,
//   height: 100%,
//   zoom: 1,
//   json("typesetting systems.json"),
// )


Recent efforts in the typesetting world have aimed at modernizing or replacing older systems. Lightweight languages like Markdown#footnote("https://daringfireball.net/projects/markdown") and AsciiDoc#footnote("https://asciidoc.org") prioritize ease of use but sacrifice typesetting power. On the other hand, advanced systems like LuaTeX @Pegourie13 attempt to extend or replace TeX while maintaining its output quality. However, these often inherit TeX's core limitations, like performance or syntax issues. LaTeX has slowly evolved with modular improvements like the L3 programming layer and a new hook system @Mittelbach24. Nevertheless, many challenges remained unsolved, especially around usability, accessibility, automation and a significantly improved user experience. We believe that the arrival of Typst is establishing a turning point in all of these issues.

== Computed documents and dynamic content <sec:computed>
Dynamic content generation is a crucial feature of modern markup languages and typesetting systems, enabling documents to adapt and update automatically based on data, user input, or external conditions. By integrating programming logic, such as loops, conditionals, and variable interpolation, these systems can produce personalized, data-driven outputs, from dynamically generated reports in LaTeX to interactive web pages in Markdown with embedded scripts. This capability reduces manual repetition, minimizes errors, and ensures consistency when dealing with large or evolving datasets. Furthermore, dynamic generation supports real-time updates in interactive documents, such as dashboards or educational materials, enhancing usability and engagement. By blending structured markup with computational power, these systems bridge the gap between static documents and flexible, automated publishing workflows, making them indispensable for technical, scientific, and web-based documentation.

Knitr @Xie18, Sweave @Leisch02, and similar computational document systems, such as RMarkdown @Baumer15 and Jupyter Notebooks, integrate code execution with document authoring, allowing authors to embed live code chunks that produce figures, tables, and statistical results within a narrative. These systems are particularly prevalent in data science and scientific writing, where reproducibility is crucial. Built on top of LaTeX or Markdown, they provide a powerful, albeit often complex, workflow that couples typesetting with dynamic content generation.

In contrast, Typst offers a more unified and modern approach: rather than embedding a separate scripting language into markup, it merges typesetting and computation into a single, consistent language. This seamless integration allows Typst to support sophisticated layout logic, styling, a even data-driven approaches without the verbosity or complexity found in the aforementioned tools. Besides, when teaming up with modern web technologies such as WebAssembly (tackled in @sec:wasm), the possibilities are almost endless.
For instance, the package Pyrunner#footnote("https://typst.app/universe/package/pyrunner") allows the execution of arbitrary chunks of Python code within a Typst document (@fig:pyrunner).

#let pyrunner-typ = read("pyrunner example.typ")
#figure(
  raw(pyrunner-typ, lang: "typ", block: true),
  caption: "Python code running at render time within a Typst document",
  kind: image,
  placement: none,
) <fig:pyrunner>

Other current WebAssembly-grounded integration solutions for computational documents in Typst are:
- Neoplot#footnote("https://github.com/KNnut/neoplot"), for generating plots with Gnuplot (see @fig:neoplot).
- Jlyfish#footnote("https://github.com/andreasKroepelin/TypstJlyfish.jl"), for integrating Julia code.
- Callisto#footnote("https://github.com/knuesel/callisto"), for reading and rendering Jupyter notebooks.
- Diagraph#footnote("https://github.com/Robotechnic/diagraph"), for binding simple Graphviz-based diagrams (see @fig:dot).
- Nulite#footnote("https://github.com/j-mueller/typst-vegalite"), for plotting Vega-based charts (like the one shown in @fig:mlevolution).


= The markup language <sec:markup>
Typst employs straightforward markup syntax for standard formatting operations. For instance, headings can be created with the `=` symbol, while text can be italicized by enclosing it in `_underscores_`.

Typst employs three distinct syntactical modes: markup, math, and code. By default, a Typst document operates in _markup mode_, which handles standard text formatting. _Math mode_ enables the composition of mathematical expressions, while _code mode_ provides access to Typst's scripting capabilities for dynamic content generation. Transitions between these modes are governed by specific syntactic markers, as outlined in @tab:modes.

#figure(
  table(
    columns: (0.55fr, 1.5fr, 1.7fr),
    inset: 5pt,
    align: left,
    stroke: .01cm,
    table.header(
      [*Mode*],
      [*Syntax*],
      [*Example*],
    ),

    [Code], [Prefix code with \#], raw("Number: #(1 + 2)", lang: "typ"),
    [Math], [Surround math with \$â€¦\$], raw("$-x$ is the opposite of $x$", lang: "typ"),
    [Markup], [Put markup in \[â€¦\]], raw("#let name = [*Typst!*]", lang: "typ"),
  ),
  caption: [Typst syntactical modes.],
  placement: none,
) <tab:modes>


All this content is written in Unicode. Typst has embraced this computing standard a first-class citizen (as can be seen in @fig:mathunicode), making it much more modern and intuitive than traditional typesetting systems like LaTeX.

#figure(
  code-grid("unicode math example.typ"),
  caption: [Example of modern Unicode use in Typst and math expressions.],
  kind: image,
  placement: none,
) <fig:mathunicode>








== Styling
Typst makes styling documents easy, flexible, and consistent with a modern and declarative approach. In certain ways, it operates very similarly to CSS, but built for typesetting. With more detail, it uses a consistent and hierarchical styling model where styles can be defined globally, applied to specific elements, or inherited through logical relationships. Typst leverages a declarative syntax combined with programmatic features, allowing users to define reusable styles, functions, and templates. For example, document-wide settings like fonts, margins, and colors can be set at the beginning, while local overrides can be applied to headings, tables, or other elements using rules and selectors. This ensures a clean separation of content and presentation while maintaining flexibility. Additionally, Typst's styling system supports dynamic adjustmentsâ€”such as conditionally changing layouts or automating typographic refinementsâ€”thanks to its built-in scripting capabilities.
#figure(
  caption: [Example of a global `set` command and `show` rule (on the heading elements) necessary to render the content of @fig:affine],
  kind: table,
  grid(
    columns: (1.5fr, 2fr),
    rows: (auto, auto),
    gutter: 1pt,
    [Global `set` rule], [Style mixin],
    [#v(.1cm)], [],
    raw("#set text(
  font: \"Cantarell\",
  ligatures: false,
  size: 9pt,
)", lang: "typst", block: true),
    raw(
      "#show heading: it => [
  #set align(center)
  #set text(9pt, weight: \"bold\")
  #block(smallcaps(it.body))
]",
      lang: "typst",
      block: true,
    ),
  ),
) <fig:setshow>
One of Typst's key strengths is its composability: styles can be defined as functions or mixins, enabling modular and reusable design systems. For instance, a custom heading style can encapsulate font choices, spacing, and numbering logic, then be reused across the document with variations. The system also handles inheritance and cascading predictably, avoiding the complexity seen in some web CSS models. By combining the rigor of traditional typesetting with modern programming paradigms, Typst provides a powerful yet intuitive way to manage document styling, whether for academic papers, technical reports, or dynamic publications. For instance, the style rules necessary to produce @fig:affine are presented in @fig:setshow.




== Control structures
Control structures in Typst are familiar and intuitive, much like those in mainstream programming languages. It supports standard constructs like `if`, `for`, `while`, `break`, `continue`, and `return`, which behave in expected ways. These can be used not only for logic and mutation but also for composing content. For example, a `for` loop can dynamically generate repeated pieces of content, and if enclosed in square brackets `[ ... ]` instead of curly braces `{ ... }`, the loop body is treated as content and gets rendered directly in the output. Typst also supports destructuring and content joining within loops, making it powerful for building structured documents programmatically.

Additionally, Typst includes short-circuiting with `and` and `or`, which act as control structures by conditionally skipping the evaluation of the second operand based on the first. This allows patterns like `x or y` to avoid runtime errors, e.g., when `y` would raise an error if `x` isn't false. Interestingly, these operators are expressive enough to replicate `if/else` behavior entirely. Typst's control flow is simple but flexible, and thoughtfully integrated with its content model, allowing for a seamless blend of logic and layout.

== Math

Typst offers robust support for mathematical expressions, providing a syntax that is both intuitive and powerful. To enter math mode, it is only necessary to enclose mathematical expressions within dollar signs (`$...$`). For display-style equations, spaces can be added or newlines between the dollar signs and the content. Typst's math mode supports a wide range of symbols and functions, including Greek letters, operators, and more. Subscripts and superscripts are handled using the underscore (`_`) and caret (`^`) symbols, respectively. For example, `$x^2$` renders as $x^2$, and `$a_b$` renders as $a_b$. Additionally, Typst automatically scales delimiters like parentheses and brackets to fit their content, similar to LaTeX's `\left` and `\right` commands. This ensures that complex expressions are rendered clearly and accurately.

Beyond basic syntax, Typst allows for advanced customization of mathematical expressions. Matrices can be defined using the `mat` function, which accepts semicolon-separated rows and comma-separated columns, such as `$mat(1, 2; 3, 4)$` to render a 2x2 matrix. Typst also supports piecewise functions through the `cases` function, enabling the definition of functions with multiple conditions in a clear format. Moreover, text can be incorporated within math expressions by enclosing it in double quotes, like `$x > 0 "if" y < 1$`. For users who prefer using Unicode symbols directly, Typst accommodates this as well, allowing for a more natural input of mathematical notation. Overall, Typst's math capabilities are designed to be both user-friendly and versatile, catering to a wide range of mathematical typesetting needs.

#figure(
  code-grid("physica example.typ"),
  caption: [Example of advanced math with the Physica package#footnote[https://typst.app/universe/package/physica].],
  kind: image,
  placement: none,
)


== Drawing capabilitues
Typst's Visualize#footnote("https://typst.app/docs/reference/visualize") module offers a comprehensive suite of tools for creating vector graphics and data visualizations directly within documents. It supports a variety of shapes and elements, including circles, ellipses, rectangles, squares, lines, polygons, and BÃ©zier curves, each customizable with parameters like fill, stroke, radius, etc. The module also allows for the inclusion of images (both raster and vector) and supports advanced styling options such as gradients and tiled patterns.

#figure(
  code-grid("gradient stack.typ"),
  caption: [Gradient stack example showing Typst drawing capabilities.],
  kind: image,
) <fig:gradient>


Typst also offers robust visualization capabilities through its extensible package ecosystem, enabling users to create high-quality plots and charts directly within their documents. Two prominent packages facilitating this are Lilaq#footnote("https://lilaq.org") and CeTZ-Plot#footnote("https://github.com/cetz-package/cetz-plot"). Lilaq provides a user-friendly interface for scientific data visualization, drawing inspiration from tools like Matplotlib and PGFplots (@fig:lilaq). It emphasizes ease of use, allowing for quick creation of plots with minimal code, and supports features like customizable color cycles (@fig:gradient), axis configurations, and various plot types. The package integrates seamlessly with Typst's styling system, ensuring consistent formatting across documents.

#figure(
  code-grid("lilaq example.typ"),
  caption: [Example of a plot made with the Lilaq plotting package.],
  kind: image,
  placement: none,
) <fig:lilaq>

On the other hand, CeTZ-Plot extends the CeTZ drawing library, offering functionalities for creating plots and charts within the CeTZ canvas environment (@fig:cetz). It supports various chart types, including pie charts, bar charts, and pyramids, and allows for detailed customization of plot elements. CeTZ-Plot is particularly suited for users who require intricate control over their visualizations and wish to integrate plots with other graphical elements.

#figure(
  code-grid("cetz example.typ"),
  caption: [Example of a Venn diagram composed through CeTZ.],
  kind: image,
  placement: none,
) <fig:cetz>

Both Lilaq and CeTZ-Plot exemplify Typst's commitment to providing flexible and powerful tools for data visualization, catering to a range of user needs from straightforward plotting to complex graphical compositions.

== Bibliographic references
Typst offers integrated support for bibliographic references, streamlining the citation process for users. It allows authors to include citations in their documents using the `cite` function or the `@key` syntax, referencing entries from bibliography files. Typst supports both BibLaTeX `.bib` files @Datta17 and Hayagriva `.yml` files as sources for bibliographic data. The system utilizes the Citation Style Language (CSL) to format citations and bibliographies @Fenner14, providing a wide range of built-in styles such as APA, MLA, IEEE, and Chicago. Users can also add custom CSL files to accommodate specific formatting requirements.

Hayagriva#footnote[https://github.com/typst/hayagriva] is a Rust-based bibliography management library developed side-by-side with Typst to work seamlessly with Typst. It introduces a YAML-backed format for bibliographic entries and incorporates a CSL processor to format both in-text citations and reference lists. Hayagriva supports all styles provided in the official CSL repository, offering users access to over 2.600 citation styles.

#figure(
  caption: [Sample of a BibTeX entry and its Hayagriva equivalent for @Corbi23.],
  kind: image,
  grid(
    columns: (4fr, 4.5fr),
    rows: (auto, auto),
    gutter: 1pt,
    raw(
      "@article{Corbi23,
  title     = {Cloud-Operated Open Literate Educational Resources: The Case of the MyBinder},
  author    = {Corbi, Alberto and Burgos, Daniel and PÃ©rez, Antonio MarÃ­a},
  journal   = {IEEE Transactions on Learning Technologies},
  volume    = {17},
  pages     = {893--902},
  year      = {2023},
  publisher = {IEEE}
}",
      lang: "bibtex",
      block: true,
    ),
    raw(
      "Corbi23:
  type: article
  title: 'Cloud-Operated Open Literate Educational Resources: The Case of the MyBinder'
  author:
  - Corbi, Alberto
  - Burgos, Daniel
  - PÃ©rez, Antonio MarÃ­a
  date: 2023
  page-range: 893â€“902
  parent:
    type: periodical
    title: IEEE Transactions on Learning Technologies
    publisher: IEEE
    volume: 17
",
      lang: "yaml",
      block: true,
    ),
  ),
) <fig:haya>




= The compiler and Command-Line interface <sec:compiler>
Typst's compiler operates differently from traditional compilers by using a reactive model that tracks dependencies and selectively re-evaluates only the modified parts of a document @Haug22. This enables instant previews during editing, as the system interprets layout instructions, styling rules, and content in real time @Madje22. A consistent styling system and an intelligent layout engine work together to resolve these elements efficiently, supporting complex features like math typesetting, dynamic templates, and figures while maintaining responsiveness.

== Typst abstract syntax tree and Rust
The compilation itself follows a structured yet flexible process. First, the input text is parsed into an abstract syntax tree (AST) using Typst's grammar rules, followed by static analysis to resolve imports, variables, and functions. After type checking and evaluating expressions, the AST is transformed into an intermediate representation (IR) containing layout directives. The compiler then computes the final document layout using a constraint-based algorithm to determine positioning, sizing, and breaks (such as pages or lines). Finally, it renders the output (e.g., PDF) based on the resolved layout. This incremental approach ensures that updates are processed efficiently, minimizing recomputation when changes occur.

Typst's choice of Rust @Klabnik23 as its underlying programming language provides several key benefits, including high performance, safety, and modern tooling. Rust's efficiency allows Typst to compile documents significantly faster than traditional LaTeX systems, with benchmarks showing near-instantaneous updates after initial compilation (e.g., 200 ms for changes in a 77-page document). The language's memory safety guarantees prevent common bugs like data races, which is critical for a typesetting system handling complex document structures. Additionally, Rust's strong type system and zero-cost abstractions enable Typst to implement features like cross-platform development, including WebAssembly for browser-based tools.

#import "@preview/pintorita:0.1.4"
#show raw.where(lang: "pintora"): it => pintorita.render(it.text)


#figure(
  placement: top,
  kind: image,
  scope: "parent",
  caption: [Pipeline of the Typst compiler, comprising four main phases: parsing, evaluation, layout, and rendering.],
  ```pintora
  mindmap
  @param layoutDirection LR
  + Source file
  ++ Parser
  +++ Syntax tree
  ++++ Interpreter
  +++++ Realization
  ++++++ Layout
  +++++++ Renderer
  ++++++++ Exporter
  +++++++++ SVG
  +++++++++ PDF
  ```,
)


== Abstraction and mutation
Abstractions in Typst enables users to manage
complexity by hiding irrelevant details through two primary mechanisms:

- Functions. Typst functions are defined using `let` syntax and support positional arguments, optional named arguments with defaults, and "argument sinks" for variadic inputs. A key convenience is the shorthand for passing content as the last argument using brackets (`[...]`). Functions implicitly join multiple content pieces and return them without requiring an explicit `return` statement, streamlining common use cases like document formatting. However, the section notes that functions in Typst lack explicit return types or visibility modifiers, which could aid in abstraction.

- Modules. Typst conflates modules with files, simplifying the language design. Modules can be imported (`#import`) or inlined (`#include`).
- Typst, highlights implicit copying to prevent side effects. This enables as a trade-off between predictability and performance.


== Value semantics and coercion
Typst employs _value semantics_, meaning values are treated as if they are copied whenever they are passed or modified. This approach prevents unintended side effects and simplifies reasoning about code. For instance, modifying a dictionary inside a function or during iteration does not affect the original structure because the function or loop receives a copy. This avoids common pitfalls such as cyclic data structures, iterator invalidation, and unintended global mutations. As a result, code becomes easier to test and debug, and features like multi-threading are safer and simpler to implement. In Typst, even function arguments and global variables behave as immutable within the scope of a function, reinforcing this isolation.

Although value semantics suggest potential performance costs due to frequent copying, Typst mitigates this with copy-on-writeâ€”data is only duplicated when it's modified and shared across references. This offers a practical balance between performance and clarity. Unlike some languages that explicitly distinguish between owned and shared data, Typst keeps its model simple and implicit, which aligns well with its role as a typesetting tool. Users can focus on layout and content without needing to understand or manage complex memory models. For example, mutating a dictionary inside a function doesn't affect the original:

```typ
#let modify(dict) = { dict.x = 100 }
#let d = (x: 1); modify(d); d.x // Still 1
```

A unique feature is implicit coercion: values like numbers or strings are automatically converted to content when used in markup. For instance, `#(1 + 2)` in markup becomes 3, while 3.0 retains its decimal in arrays for debugging clarity. Strings differ from contentâ€”they lack styling unless coerced, as in `#"Hello"`, which renders as "Hello".

== Modules
As aforementioned, Typst's other form of abstraction is modules. There are three ways to _import_ a module:

- `#import "mymodule.typ"` makes `mymodule` _visible_. Then, it is possible to write `mymodule.functionality` to access what it is
  defined with `let functionality = ...` in `mymodule.typ`.
- `#import "mymodule.typ": functionality` puts `functionality` directly in scope, so that a prefix is not needed anymore.
- `#include "mymodule.typ"` inlines the _content_ (and only the content) from "mymodule.typ".

Modules do not give the user/developer any way to mark items as
public or private. Thus every `let` statement in the whole module is exported (_public_). Some users#footnote("https://justinpombrio.net/2024/11/30/typst.html") have suggested some _solutions_, such as extending `set/show` to user-defined functions (e.g., `set sequence(codon-sep: "-")`) and improving `show` to tweak elements without reimplementing them entirely, like adding decorations to headings robustly.


== Packages <sec:package>
As with LaTeX, Typst also supports the addition of functionalities via packages. A Typst package is a self-contained collection of Typst source files and assets, structured around a mandatory `typst.toml` manifest file located at the package root. This manifest specifies essential metadata such as the package's `name`, `version`, and `entrypoint`, which points to the main `.typ` file to be evaluated upon import. Additional optional fields like `authors`, `license`, and `description` can also be included. The internal organization of the package is flexible, allowing authors to structure files and directories as they see fit, provided that the `entrypoint` path is correctly specified. All paths within the package are resolved relative to the package root, ensuring encapsulation and preventing access to files outside the package. Packages are typically stored in a directory hierarchy following the pattern `{namespace}/{name}/{version}` and can be imported into Typst documents using the syntax `#import "@{namespace}/{name}:{version}"`. For local development or experimentation, packages can be placed in designated local data directories, making them accessible without publishing to the shared repository.

== Web technologies <sec:wasm>
As introduced in @sec:computed, Typst leverages WebAssembly (WASM) to enable its core functionalities to run efficiently in web environments @Haas17. This approach allows Typst to execute its typesetting engine directly within web browsers, facilitating seamless integration into web-based applications and services. By compiling its Rust-based codebase to WASM, Typst ensures consistent performance across different platforms without the need for native installations. This strategy not only enhances accessibility but also simplifies the deployment process, making Typst a versatile tool for developers and content creators alike.

As an example, the Neoplot package for Typst is a specialized tool designed to integrate Gnuplot (a powerful open-source plotting engine @Janert16) into Typst documents (@fig:neoplot). The Grayness#footnote("https://github.com/nineff/grayness") package allows the application of complex image manipulation algorithms (@fig:mileva).


#figure(
  code-grid("neoplot example.typ"),
  caption: [Neoplot WASM-based package example.],
  kind: image,
  placement: none,
) <fig:neoplot>

#import "@preview/grayness:0.3.0": image-grayscale, image-blur, image-show, image-huerotate, image-darken

#let data = read("mileva.jpg", encoding: none)
#figure(
  kind: image,

  [#stack(dir: ltr, spacing: 45pt, [`image-show`], [`image-blur`], [`image-darken`])
    #stack(
      dir: ltr,
      spacing: 2pt,
      image-show(data, width: 33%),
      image-blur(data, sigma: 20, width: 33%),
      image-darken(data, amount: 0.4, width: 33%),
    )],
  caption: [Complex image manipulation via the Grayness WASM plugin.],
) <fig:mileva>
// Hayagriva

// https://typst.app/docs/reference/model/
//https://yurichev.com/mirrors/knuth1989.pdf
//

== Security <sec:sec>
The Typst compiler ensures safety by implementing strict security measures that prevent potentially harmful operations during document compilation. It restricts file access to the project's root directory, disallowing reading or writing files outside this scope, thereby safeguarding against unauthorized data access. Additionally, Typst prohibits features like shell escapes and network requests, which could otherwise be exploited for arbitrary code execution or data exfiltration (that currently may take place in the TeX-sphere @Lacombe21 @Kim24). These design choices collectively create a secure environment, making Typst safe to use even with untrusted input.



== Instrospection
Typst's introspection system provides a suite of functions that enable dynamic interaction with a document's structure and content. Central to this system are functions like `counter` and `query`. The `counter` function allows for tracking and manipulating counts of elements such as pages, headings, figures, and equations. Users can access current counter values, display them in various formats, and even define custom counters for specific needs. For instance, one can create a custom counter to number specific elements uniquely throughout the document. On the other hand, the `query` function facilitates searching the document for elements that match certain criteria, such as all headings of a particular level or elements with specific labels. This is particularly useful for generating dynamic content like tables of contents or lists of figures, as it allows for real-time retrieval and display of relevant elements based on the document's current state.

Complementing these are functions like `here`, `locate`, and `metadata`, which offer deeper insights into the document's structure:
- The `here` function retrieves the current location within the document, which can be used in conjunction with other functions to determine positional information. For example, combining `here` with `query` can yield the number of specific elements preceding the current point in the document.
- The `locate` function identifies the position of a specific element, allowing for precise referencing or manipulation based on location.
- Additionally, the `metadata` function enables embedding arbitrary values into the document without producing visible content, which can later be retrieved using `query`. This is particularly useful for storing and accessing auxiliary information that informs document behavior or content generation.

== Integrated development environments
Typst integrates seamlessly with many of the existen integrated development environments, such as Visual Studio Code (@fig:vscode). For instance, extensions like Tinymist#footnote("https://github.com/Myriad-Dreamin/tinymist"), provide a comprehensive environment for Typst document creation. Tinymist offers features such as syntax highlighting, real-time previews, code completion, and error diagnostics, enhancing the editing experience. Users can initialize Typst projects using built-in templates, format documents with LSP-enhanced formatters, and manage local packages directly within VS Code. Additionally, extensions like Typst Sync facilitate synchronization of local packages with remote repositories, streamlining collaborative workflows. These tools collectively transform almost any code editor or development platform into a powerful solution for Typst-based typesetting.
#figure(
  image("vscode.jpg"),
  kind: image,
  caption: [Typst can also be used through modern code editors such as Visual Studio Code.],
  placement: top,
) <fig:vscode>


= Web application <sec:typstapp>
The shift to cloud-based tools is revolutionizing content creation, academic work, and document editing, with platforms like Binder @Corbi23, Jupyter, and Overleaf leading the charge in specialized domains. As stated in @sec:latex, Overleaf has transformed academic writing by offering cloud-based LaTeX editing with live collaboration, version control, and seamless publisher integration. These tools, alongside mainstream platforms like Google Docs and Notion, highlight a broader trend: the cloud is breaking down barriers to access, fostering collaboration, and integrating advanced workflows (like AI-assisted editing and automated publishing) that were once confined to local software. As a result, education, research, and professional documentation are becoming more dynamic, inclusive, and efficient.


XXX ,Overleaf or other alternatives like Papeeria and Authorea. These two offer similar collaborative LaTeX editing capabilities but have smaller user bases. PLMlatex, developed by the French National Centre for Scientific Research (CNRS), is a French-language LaTeX editor based on the open-source version of Overleaf. It provides a user interface and functionality closely resembling Overleaf, though it lacks certain premium features. CoCalc also supports LaTeX editing alongside tools for calculations, research, and collaboration. All these services may suffer from security vulnerabilities, as commented in @sec:sec.

The Typst (@fig:typstapp) online editor is a collaborative, web-based platform designed for creating and typesetting documents with Typst, a modern markup-based typesetting system. It offers a seamless writing experience with features like instant preview, syntax highlighting, and autocompletion, making it ideal for drafting academic papers, technical reports, and other long-form documents. The editor splits the interface into two panels: a source panel for writing Typst markup and a preview panel that renders the document in real time. Users can easily format text, insert images, equations, and bibliographies, and leverage Typst's scripting capabilities for advanced customization. The web app also supports collaboration through the WebSockets standard @Lombardi2015, allowing users to share projects, track changes, and integrate with tools like Zotero and Mendeley for reference management.

The development team is actively working on improvements, including better mobile usability and additional features like offline PWA support and private templates for teams. The editor is available for free with basic features, while a Pro subscription unlocks advanced capabilities like Git integration, presentation mode, and increased storage.


= Adoption of Typst <sec:adoption>

Typst has garnered significant interest since its public beta launch and the open-sourcing of its compiler in March 2023. The platform's user-friendly syntax and modern features have attracted a growing community, with its GitHub repository amassing over 37,000 stars, indicating strong developer engagement. While Typst is gaining traction among academics and researchers, its adoption in formal publishing remains limited. Currently, most scientific journals do not accept Typst files for submission, and there is no direct export to LaTeX, which poses challenges for integration into traditional academic workflows. Nonetheless, Typst's open-source nature and active development community suggest a promising future as it continues to evolve and address the needs of its users.

The Typst community is also providing template for the most reputed scientific editorials and journals (@fig:papers).

#figure(
  placement: top,
  scope: "parent",
  caption: [Some journal Typst-based templates already qualified to be used for editorial pourposes: _
Joint Accelerator Conferences Website_#footnote("https://jacow.org"), _Journal of Machine Learning Research_#footnote("https://www.jmlr.org"), _Institute of Electrical and Electronics Engineers_#footnote("https://ieee.org"), and _Multidisciplinary Digital Publishing Institute_#footnote("https://mdpi.com").],
  stack(
    dir: ltr,
    spacing: 3pt,
    image("jacow.jpg", width: 25%),
    line(end: (0%, 25%), start: (0%, 2.5%), stroke: .1pt),
    image("jmlr.jpg", width: 25%),
    line(end: (0%, 25%), start: (0%, 2.5%), stroke: .1pt),
    image("ieee.jpg", width: 25%),
    line(end: (0%, 25%), start: (0%, 2.5%), stroke: .1pt),
    image("mdpi.jpg", width: 25%),
    line(end: (0%, 25%), start: (0%, 2.5%), stroke: .1pt),
  ),
) <fig:papers>

Finally, although not its intention, Typst.app can also be used as an scientific preprint dissemination platform. Scientific preprint repositories like arXiv and HAL play a crucial role in the rapid publication of research findings across various academic disciplines. These platforms allow researchers to share their work publicly before it undergoes formal peer review, enabling immediate access to new ideas and results.



â€‹The `diagraph` package is a Typst extension that allows users to embed Graphviz diagrams directly within Typst documents (@fig:dot).

#figure(
  image("typstapp.jpg", width: 100%),
  scope: "parent",
  placement: auto,
  caption: [Screenshot of the Typst.app web application for online Typst editing and collaboration.],
) <fig:typstapp>


#figure(
  code-grid("diagraph example.typ"),
  caption: [Example of a realtime rendered Graphviz-based diagram.],
  kind: image,
) <fig:dot>


#figure(
  image("universe.jpg"),
  placement: bottom,
  scope: "parent",
  caption: "A screenshot ot the Typst Universe website, highlighting the CeTZ package.",
) <fig:universe>

= Typst Universe <sec:universe>
Typst Universe is an online platform that offers a curated collection of templates and packages designed to enhance and automate Typst documents (@fig:universe). Users can find resources ranging from thesis templates to visualization tools, all aimed at simplifying the document creation process. The platform allows users to search, browse categories, and submit their own contributions, fostering a collaborative environment for Typst users. Some of the packages present in this site are briefly described in @tab:packages.

#figure(
  align(center)[#table(
      columns: (0.9fr, 4fr),
      align: (right, left), stroke: 0.01cm,
      table.header([*Package*], [*Description*]),
      table.hline(),
      [Touying], [A powerful package for creating presentation
        slides.],
      [Unify], [Simplifies the typesetting of numbers, units,
        and ranges, similar to LaTeX's
        `siunitx`.],
      [Finite], [Renders finite automata diagrams using
        CeTZ.],
      [Tiaoma], [A barcode generator that supports various
        barcode types by compiling Zint to
        WebAssembly.],
      [Problemst], [Provides a simple template for problem sets,
        homeworks, or
        assignments.],
    )],
  kind: table,
  caption: "Some of the most reputed packages found in Typst Universe.",
) <tab:packages>




= Conclusions
Typst is a markup language for typesetting documents, combining ease of use, speed, and versatility. It transforms plain text files with markup into polished PDFs. Ideal for long-form writing, Typst excels at creating essays, articles, scientific papers, books, reports, and homework assignments. It also shines in technical fields, such as mathematics, physics, and engineering thanks to its robust support for mathematical notation. Additionally, its powerful styling and automation capabilities make it perfect for document sets with a consistent design, like a book series or branded publications.

Certainly, has happened with the evolution of TeX @Knuth89, Typst will still continue to evolve and get better.

= Declaration of conflicts of interest
We just want to declare our love to Typst and IJIMAI.
= Acknowledgment
Thanks, Typst!

// #set text(font: "Consolas")
// #import "@preview/messeji:0.1.0": messeji, parse-json
// #let my-messages = (
//   (
//     msg: "Â¿QuÃ© vas a hacer estos dÃ­as de Pascua?",
//     from_me: false,
//   ),
//   (
//     msg: "Estudiar fÃ­sica a tope ðŸ‘Š",
//     from_me: true,
//   ),(
//     msg: "Â¿Tienes miedo de Alberto?",
//     from_me: false,
//   ),(
//     msg: "Mucho!! ðŸ˜±",
//     from_me: true,
//   )
// )
// #messeji(chat-data: my-messages)
//
//
//#import "@preview/messeji:0.1.0": messeji, parse-json
//#let parsed-data = parse-json("mychat.json")
//#messeji(chat-data: parsed-data)
ss
